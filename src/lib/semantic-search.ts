import { Pinecone } from '@pinecone-database/pinecone'
import { GoogleGenerativeAI } from '@google/generative-ai'
import { chunk } from 'lodash'
import { NFTTopDealItem, NFTTraits } from '&/types'
import { getNFTTopDeals, getNFTTraits } from '&/actions'
import { ColorDescriptionSchema, NFTVisualDescription } from './schema'
import { getPriceCategory } from './utils'

async function getColorDescriptions(
  palette: string[],
  genAI: GoogleGenerativeAI
): Promise<string[]> {
  const model = genAI.getGenerativeModel({
    model: 'gemini-1.5-flash',
    systemInstruction: `You are a color analysis expert. For the given array of hex color codes, return an array of descriptive terms.
      
      Requirements:
      - Return ONLY a JSON array of strings
      - Each string should be a single word
      - Include both color names and qualities (e.g., "red", "bright", "dark")
      - Do not include any explanation, markdown, or additional text
      - Do not include quotes or backticks around the response
      
      Example input: ["#FF0000"]
      Example output: ["red","bright","vibrant"]`,
    generationConfig: {
      responseMimeType: 'application/json',
      responseSchema: ColorDescriptionSchema,
    },
  })

  try {
    const result = await model.generateContent(JSON.stringify(palette))
    const response = result.response.text()
    return JSON.parse(response.replace(/'/g, `"`))
  } catch (e) {
    console.error('Error processing color descriptions:', e)
    return palette.map(() => 'colourful')
  }
}

async function getVisualDescriptions(
  imageURLs: string[],
  genAI: GoogleGenerativeAI
): Promise<string[]> {
  const systemInstruction = `You are a visual feature extraction model specialized in analyzing images and providing concise, descriptive terms. Given a URL to an NFT image (usually a small thumbnail or preview), your goal is to return a **detailed textual description** of what is visible in the image, focusing on key **visual elements** like objects, characters, style, mood, and notable visual features. 
  
  Your description should be **specific**, **descriptive**, and **to the point**, avoiding generic terms like "image of" or "art." Ensure that the descriptions cover elements such as:
  - Primary objects or characters (e.g., "a cartoon ape", "a spaceship")
  - Key attributes of those objects (e.g., "wearing sunglasses", "with a glowing neon background")
  - Visual style or mood (e.g., "retro", "dark and moody", "vibrant", "abstract")
  - Any unique visual qualities (e.g., "with a holographic texture", "glowing elements")
  
  **Requirements:**
  - Only return **descriptive terms** and avoid extraneous explanations or any unnecessary text.
  - Your response should be an array of **single sentence** or an array of **short list of words/phrases** for each image that adequately summarize each of the images you will be receiving
  - Your descriptions should focus on **relevant visual features** for searching purposes and will be used in the indexing system.
  - Please do **not** provide any explanations or meta-information about the image (e.g., "this image was generated by AI").
  - Do not include any markdown, quotes, or backticks in the response.
  
  ### Example Input:
  [NFT Image URL: "https://example.com/nft-image.jpg",
  NFT Image URL2: "https://example.com/nft-image2.jpg"]
  
  ### Example Output:
  ["a cartoon ape wearing sunglasses, colorful graffiti background, playful, vibrant, with a futuristic touch", "second detailed description of another image"]
  
  ---
  
  Please ensure that the generated visual description is concise, relevant, and focused on observable features in the image.`

  const imageResponses = await Promise.allSettled(
    imageURLs.map(async imageURL => {
      const mimeType = imageURL.endsWith('jpg')
        ? 'image/jpeg'
        : imageURL.endsWith('png')
        ? 'image/png'
        : ('image/webp' as const)
      const imageResp = await fetch(imageURL).then(res => res.arrayBuffer())
      return { imageResp, mimeType }
    })
  )
  const visionModel = genAI.getGenerativeModel({
    model: 'gemini-1.5-flash',
    systemInstruction,
    generationConfig: {
      responseMimeType: 'application/json',
      responseSchema: NFTVisualDescription,
    },
  })
  try {
    const result = await visionModel.generateContent([
      ...imageResponses
        .filter(imageResp => imageResp.status === 'fulfilled')
        .map(imageResp => {
          const { imageResp: buffer, mimeType } = imageResp.value
          return {
            inlineData: {
              data: Buffer.from(buffer).toString('base64'),
              mimeType,
            },
          }
        }),
      'Generate a detailed visual description of these images',
    ])
    const response = result.response.text()
    console.log('result from vision model: ', response)
    return JSON.parse(response.replace(/'/g, `"`))
  } catch (err) {
    console.error('error from vision model', err)
    return Array(imageURLs.length).fill('')
  }
}

function createSearchableNFTText(
  nft: NFTTopDealItem[number],
  colorDescriptions: string[],
  visualDescription: string,
  traits: NFTTraits
): string {
  const nftTraits = traits.traits
  const priceRange = getPriceCategory(nft.listed_eth_price)
  const sentence =
    nftTraits.length > 0
      ? nftTraits
          ?.map(trait => `${trait.trait_type}: ${trait.value}`)
          .join(', ')
      : ''
  return [
    `Collection: ${nft.collection_name}`,
    `Token ID: ${nft.token_id}`,
    `Platform: ${nft.marketplace}`,
    `Blockchain: ${nft.chain_id === '1' ? 'Ethereum' : nft.chain_id}`,
    `Price: ${nft.listed_eth_price} ETH`,
    `Price category: ${priceRange}`,
    `Deal score: ${nft.deal_score}`,
    `Colors: ${colorDescriptions.join(', ')}`,
    `Visual Features: ${visualDescription}`,
    sentence ? `This character has the following traits: ${sentence}.` : ``,
    `Listed: ${new Date(nft.listing_timestamp).toISOString()}`,
    `Closing: ${new Date(nft.closing_timestamp).toISOString()}`,
  ].join(' ')
}

export function pc() {
  const apiKey = process.env.PINECONE_API_KEY
  if (!apiKey) throw new Error('Pinecone API Key not set')
  return new Pinecone({
    apiKey,
  })
}

export const index = pc().index('nft-embeddings')

async function validateImageUrl(url: string): Promise<boolean> {
  try {
    const response = await fetch(url, { method: 'HEAD' })
    return response.ok
  } catch {
    return false
  }
}

async function upsertToPinecone(vectors: any[], pinecone: Pinecone) {
  const UPSERT_BATCH_SIZE = 100
  const batches = chunk(vectors, UPSERT_BATCH_SIZE)

  for (const batch of batches) {
    await index.upsert(
      batch.map(vector => ({
        id: vector.id,
        values: vector.values,
        metadata: vector.metadata,
      }))
    )
  }
}

const RATE_LIMITS = {
  nftAPI: {
    requestsPerMinute: 20,
    delayMs: 3500,
  },
  geminiAPI: {
    requestsPerMinute: 15,
    delayMs: 4500,
  },
}

const lastCallTimes = {
  nftAPI: 0,
  geminiAPI: 0,
}

export async function rateLimit(type: 'nftAPI' | 'geminiAPI') {
  const now = Date.now()
  const delayMs = RATE_LIMITS[type].delayMs
  const timeSinceLastCall = now - lastCallTimes[type]

  if (timeSinceLastCall < delayMs) {
    await new Promise(resolve =>
      setTimeout(resolve, delayMs - timeSinceLastCall)
    )
  }

  lastCallTimes[type] = Date.now()
}

async function batchProcessNFTs(
  nfts: NFTTopDealItem,
  genAI: GoogleGenerativeAI
) {
  const BATCH_SIZE = 3
  const batches = chunk(nfts, BATCH_SIZE)
  const allResults = []

  for (const batch of batches) {
    const validNFTs = await Promise.all(
      batch.map(async nft => {
        await rateLimit('nftAPI')
        const isValid = await validateImageUrl(nft.thumbnail_url)
        return isValid ? nft : null
      })
    )
    const filteredBatch = validNFTs.filter(nft => nft !== null)
    if (filteredBatch.length === 0) continue
    await rateLimit('geminiAPI')
    const colorDescriptions = await getColorDescriptions(
      filteredBatch.flatMap(nft => nft.thumbnail_palette),
      genAI
    )

    await rateLimit('geminiAPI')
    const visualDescriptions = await getVisualDescriptions(
      filteredBatch.map(nft => nft.thumbnail_url),
      genAI
    )
    const batchResults = await Promise.all(
      filteredBatch.map(async (nft, idx) => {
        await rateLimit('nftAPI')
        const nftTraits = await getNFTTraits(
          +nft.chain_id,
          nft.contract_address,
          nft.token_id
        )

        const startIdx = idx * nft.thumbnail_palette.length
        const nftColorDescriptions = colorDescriptions.slice(
          startIdx,
          startIdx + nft.thumbnail_palette.length
        )

        const searchableText = createSearchableNFTText(
          nft,
          nftColorDescriptions,
          visualDescriptions[idx],
          nftTraits ?? { traits: [] }
        )

        await rateLimit('geminiAPI')
        const embeddingModel = genAI.getGenerativeModel({
          model: 'text-embedding-004',
        })
        const embeddingResult = await embeddingModel.embedContent(
          searchableText
        )

        return {
          id: `${nft.chain_id}-${nft.contract_address}-${nft.token_id}`,
          values: embeddingResult.embedding.values,
          metadata: {
            ...nft,
            searchableText,
            colorDescriptions: nftColorDescriptions,
            visualDescription: visualDescriptions[idx],
          },
        }
      })
    )

    allResults.push(...batchResults)
  }

  return allResults
}

export async function seedVectorDatabase() {
  const GEMINI_API_KEY = process.env.GOOGLE_GENERATIVE_AI_API_KEY
  if (!GEMINI_API_KEY) throw new Error('Gemini API Key is missing')

  const genAI = new GoogleGenerativeAI(GEMINI_API_KEY)

  try {
    const nftTopDeals = await getNFTTopDeals()
    if (!nftTopDeals) throw new Error('Failed to fetch NFT data')

    const vectors = await batchProcessNFTs(nftTopDeals, genAI)

    await upsertToPinecone(vectors, pc())

    return {
      success: true,
      processed: vectors.length,
    }
  } catch (error) {
    console.error('Error seeding vector database:', error)
    throw error
  }
}
